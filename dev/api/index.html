<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SimpleDifferentialOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleDifferentialOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">﻿SimpleDifferentialOperators.jl</a></li><li><a class="toctext" href="../notebooks/">Notebooks</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><ul><li><a href="#SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{Reflecting,Reflecting},Any}"><code>SimpleDifferentialOperators.DifferentialOperator</code></a></li><li><a href="#SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{Mixed,Mixed},BackwardFirstDifference}"><code>SimpleDifferentialOperators.DifferentialOperator</code></a></li><li><a href="#SimpleDifferentialOperators.ExtensionDifferentialOperator-Tuple{AbstractRange,BackwardFirstDifference}"><code>SimpleDifferentialOperators.ExtensionDifferentialOperator</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₊-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₊</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₊bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₊bc</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₋-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₋</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₋bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₋bc</code></a></li><li><a href="#SimpleDifferentialOperators.L₂-Tuple{Any}"><code>SimpleDifferentialOperators.L₂</code></a></li><li><a href="#SimpleDifferentialOperators.L₂bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₂bc</code></a></li><li><a href="#SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{Reflecting,Reflecting}}"><code>SimpleDifferentialOperators.extrapolatetoboundary</code></a></li><li><a href="#SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{Mixed,Mixed}}"><code>SimpleDifferentialOperators.extrapolatetoboundary</code></a></li><li><a href="#SimpleDifferentialOperators.interiornodes-Tuple{Any,Any}"><code>SimpleDifferentialOperators.interiornodes</code></a></li><li><a href="#SimpleDifferentialOperators.interiornodes-Tuple{Any}"><code>SimpleDifferentialOperators.interiornodes</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{Mixed,Mixed},BackwardFirstDifference}" href="#SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{Mixed,Mixed},BackwardFirstDifference}"><code>SimpleDifferentialOperators.DifferentialOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DifferentialOperator(x̄, bc::Tuple{Mixed, Mixed}, method::DifferenceMethod)</code></pre><p>Returns a discretized differential operator of <code>length(x̄)</code> by <code>length(x̄)</code> matrix under mixed boundary conditions from <code>bc</code> using finite difference method specified by <code>method</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; DifferentialOperator(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)), BackwardFirstDifference())
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 7 stored entries:
  [1, 1]  =  Inf
  [2, 1]  =  -1.0
  [2, 2]  =  1.0
  [3, 2]  =  -1.0
  [3, 3]  =  1.0
  [4, 3]  =  -1.0
  [4, 4]  =  1.0

julia&gt; DifferentialOperator(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)), ForwardFirstDifference())
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 7 stored entries:
  [1, 1]  =  -1.0
  [1, 2]  =  1.0
  [2, 2]  =  -1.0
  [2, 3]  =  1.0
  [3, 3]  =  -1.0
  [3, 4]  =  1.0
  [4, 4]  =  -0.5

julia&gt; DifferentialOperator(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)), CentralSecondDifference())
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 10 stored entries:
  [1, 1]  =  -Inf
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  -2.0
  [3, 2]  =  1.0
  [2, 3]  =  1.0
  [3, 3]  =  -2.0
  [4, 3]  =  1.0
  [3, 4]  =  1.0
  [4, 4]  =  -1.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L41-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{Reflecting,Reflecting},Any}" href="#SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{Reflecting,Reflecting},Any}"><code>SimpleDifferentialOperators.DifferentialOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DifferentialOperator(x̄, bc::Tuple{Reflecting, Reflecting}, method::DifferenceMethod)</code></pre><p>Returns a discretized differential operator of <code>length(x̄)</code> by <code>length(x̄)</code> matrix under reflecting boundary conditions from <code>bc</code> using finite difference method specified by <code>method</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; DifferentialOperator(x̄, (Reflecting(), Reflecting()), BackwardFirstDifference())
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 7 stored entries:
  [1, 1]  =  0.0
  [2, 1]  =  -1.0
  [2, 2]  =  1.0
  [3, 2]  =  -1.0
  [3, 3]  =  1.0
  [4, 3]  =  -1.0
  [4, 4]  =  1.0

julia&gt; DifferentialOperator(x̄, (Reflecting(), Reflecting()), ForwardFirstDifference())
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 7 stored entries:
  [1, 1]  =  -1.0
  [1, 2]  =  1.0
  [2, 2]  =  -1.0
  [2, 3]  =  1.0
  [3, 3]  =  -1.0
  [3, 4]  =  1.0
  [4, 4]  =  0.0

julia&gt; DifferentialOperator(x̄, (Reflecting(), Reflecting()), CentralSecondDifference())
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 10 stored entries:
  [1, 1]  =  -1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  -2.0
  [3, 2]  =  1.0
  [2, 3]  =  1.0
  [3, 3]  =  -2.0
  [4, 3]  =  1.0
  [3, 4]  =  1.0
  [4, 4]  =  -1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L1-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.ExtensionDifferentialOperator-Tuple{AbstractRange,BackwardFirstDifference}" href="#SimpleDifferentialOperators.ExtensionDifferentialOperator-Tuple{AbstractRange,BackwardFirstDifference}"><code>SimpleDifferentialOperators.ExtensionDifferentialOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ExtensionDifferentialOperator(x̄, method::DifferenceMethod)</code></pre><p>Returns a discretized differential operator of <code>length(x̄)</code> by <code>length(x̄) + 2</code> matrix whose first and last columns are applied to the ghost nodes just before <code>x̄[1]</code> and <code>x̄[end]</code> respectively under no boundary condition using finite difference method specified by <code>method</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; ExtensionDifferentialOperator(x̄, BackwardFirstDifference())
4×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 8 stored entries:
  [1, 1]  =  -1.0
  [1, 2]  =  1.0
  [2, 2]  =  -1.0
  [2, 3]  =  1.0
  [3, 3]  =  -1.0
  [3, 4]  =  1.0
  [4, 4]  =  -1.0
  [4, 5]  =  1.0

julia&gt; ExtensionDifferentialOperator(x̄, ForwardFirstDifference())
4×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 8 stored entries:
  [1, 2]  =  -1.0
  [1, 3]  =  1.0
  [2, 3]  =  -1.0
  [2, 4]  =  1.0
  [3, 4]  =  -1.0
  [3, 5]  =  1.0
  [4, 5]  =  -1.0
  [4, 6]  =  1.0

julia&gt; ExtensionDifferentialOperator(x̄, CentralSecondDifference())
4×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 12 stored entries:
  [1, 1]  =  1.0
  [1, 2]  =  -2.0
  [2, 2]  =  1.0
  [1, 3]  =  1.0
  [2, 3]  =  -2.0
  [3, 3]  =  1.0
  [2, 4]  =  1.0
  [3, 4]  =  -2.0
  [4, 4]  =  1.0
  [3, 5]  =  1.0
  [4, 5]  =  -2.0
  [4, 6]  =  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/extensionoperators.jl#L1-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₊-Tuple{Any}" href="#SimpleDifferentialOperators.L₁₊-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₊</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₊(x̄)</code></pre><p>Returns a discretized first-order differential operator of <code>length(x̄)</code> by <code>length(x̄) + 2</code> matrix using forward difference under no boundary condition.</p><p>The first and last columns are applied to the ghost nodes just before <code>x̄[1]</code> and <code>x̄[end]</code> respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; Array(L₁₊(x̄))
4×6 Array{Float64,2}:
 0.0  -1.0   1.0   0.0   0.0  0.0
 0.0   0.0  -1.0   1.0   0.0  0.0
 0.0   0.0   0.0  -1.0   1.0  0.0
 0.0   0.0   0.0   0.0  -1.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L214-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₊bc-Tuple{Any,Any}" href="#SimpleDifferentialOperators.L₁₊bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₊bc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₊bc(x̄, bc::Tuple{BoundaryCondition, BoundaryCondition})</code></pre><p>Returns a discretized first-order differential operator of <code>length(x̄)</code> by <code>length(x̄)</code> matrix using forward difference under boundary conditions specified by <code>bc</code>.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; L₁₊bc(x̄, (Reflecting(), Reflecting()))
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 7 stored entries:
  [1, 1]  =  -1.0
  [1, 2]  =  1.0
  [2, 2]  =  -1.0
  [2, 3]  =  1.0
  [3, 3]  =  -1.0
  [3, 4]  =  1.0
  [4, 4]  =  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L149-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₋-Tuple{Any}" href="#SimpleDifferentialOperators.L₁₋-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₋</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₋(x̄)</code></pre><p>Returns a discretized first-order differential operator of <code>length(x̄)</code> by <code>length(x̄) + 2</code> matrix using backward difference under no boundary condition.</p><p>The first and last columns are applied to the ghost nodes just before <code>x̄[1]</code> and <code>x̄[end]</code> respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 1:3
1:3

julia&gt; Array(L₁₋(x̄))
1×3 Array{Float64,2}:
 -1.0  1.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L194-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₋bc-Tuple{Any,Any}" href="#SimpleDifferentialOperators.L₁₋bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₋bc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₋bc(x̄, bc::Tuple{BoundaryCondition, BoundaryCondition})</code></pre><p>Returns a discretized first-order differential operator of <code>length(x̄)</code> by <code>length(x̄)</code> matrix using backward difference under boundary conditions specified by <code>bc</code>.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; L₁₋bc(x̄, (Reflecting(), Reflecting()))
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 7 stored entries:
  [1, 1]  =  0.0
  [2, 1]  =  -1.0
  [2, 2]  =  1.0
  [3, 2]  =  -1.0
  [3, 3]  =  1.0
  [4, 3]  =  -1.0
  [4, 4]  =  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L126-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₂-Tuple{Any}" href="#SimpleDifferentialOperators.L₂-Tuple{Any}"><code>SimpleDifferentialOperators.L₂</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₂(x̄)</code></pre><p>Returns a discretized second-order differential operator of <code>length(x̄)</code> by <code>length(x̄) + 2</code> matrix using central difference under no boundary condition.</p><p>The first and last columns are applied to the ghost nodes just before <code>x̄[1]</code> and <code>x̄[end]</code> respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5 

julia&gt; Array(L₂(x̄))
4×6 Array{Float64,2}:
 1.0  -2.0   1.0   0.0   0.0  0.0
 0.0   1.0  -2.0   1.0   0.0  0.0
 0.0   0.0   1.0  -2.0   1.0  0.0
 0.0   0.0   0.0   1.0  -2.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L237-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₂bc-Tuple{Any,Any}" href="#SimpleDifferentialOperators.L₂bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₂bc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₂bc(x̄, bc::Tuple{BoundaryCondition, BoundaryCondition})</code></pre><p>Returns a discretized second-order differential operator of <code>length(x̄)</code> by <code>length(x̄)</code> matrix using central difference under boundary conditions specified by <code>bc</code>.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; L₂bc(x̄, (Reflecting(), Reflecting()))
4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 10 stored entries:
  [1, 1]  =  -1.0
  [2, 1]  =  1.0
  [1, 2]  =  1.0
  [2, 2]  =  -2.0
  [3, 2]  =  1.0
  [2, 3]  =  1.0
  [3, 3]  =  -2.0
  [4, 3]  =  1.0
  [3, 4]  =  1.0
  [4, 4]  =  -1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L172-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{Mixed,Mixed}}" href="#SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{Mixed,Mixed}}"><code>SimpleDifferentialOperators.extrapolatetoboundary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extrapolatetoboundary(v, x̄, bc::Tuple{Mixed, Mixed})</code></pre><p>Returns a <code>length(x̄)</code>-vector whose <code>2:(length(x̄)-1)</code> elements are <code>v</code>, the first and last element are extrapolated <code>v</code> on the boundaries of <code>x̄</code> according to boundary conditions <code>bc</code> given.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; x = interiornodes(x̄)
1:4

julia&gt; v = (x -&gt; x^2).(x)
4-element Array{Int64,1}:
  1
  4
  9
 16

julia&gt; extrapolatetoboundary(v, x̄, (Mixed(ξ = 1), Mixed(ξ = 1)))
6-element Array{Float64,1}:
 Inf
   1.0
   4.0
   9.0
  16.0
   8.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/utilities/extrapolatetoboundary.jl#L1-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{Reflecting,Reflecting}}" href="#SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{Reflecting,Reflecting}}"><code>SimpleDifferentialOperators.extrapolatetoboundary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extrapolatetoboundary(v, x̄, bc::Tuple{Reflecting, Reflecting})</code></pre><p>Returns a <code>length(x̄)</code>-vector whose <code>2:(length(x̄)-1)</code> elements are <code>v</code>, the first and last element are extrapolated <code>v</code> on the boundaries of <code>x̄</code> according to boundary conditions <code>bc</code> given.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; x = interiornodes(x̄)
1:4

julia&gt; v = (x -&gt; x^2).(x)
4-element Array{Int64,1}:
  1
  4
  9
 16

julia&gt; extrapolatetoboundary(v, x̄, (Reflecting(), Reflecting()))
6-element Array{Int64,1}:
  1
  1
  4
  9
 16
 16</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/utilities/extrapolatetoboundary.jl#L48-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.interiornodes-Tuple{Any,Any}" href="#SimpleDifferentialOperators.interiornodes-Tuple{Any,Any}"><code>SimpleDifferentialOperators.interiornodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interiornodes(x̄, bc)</code></pre><p>Returns an interior grid corresponding to the boundary condition <code>bc</code> given extended grid <code>x̄</code>.</p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; interiornodes(x̄, (Reflecting(), Reflecting()))
1:4

julia&gt; x̄ = [1.0; 1.5; 1.7]
3-element Array{Float64,1}:
 1.0
 1.5
 1.7

julia&gt; interiornodes(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)))
1-element Array{Float64,1}:
 1.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L284-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.interiornodes-Tuple{Any}" href="#SimpleDifferentialOperators.interiornodes-Tuple{Any}"><code>SimpleDifferentialOperators.interiornodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interiornodes(x̄)</code></pre><p>Returns an interior grid of length <code>length(x̄)-2</code> given extended grid <code>x̄</code>.</p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; interiornodes(x̄)
1:4

julia&gt; x̄ = [1.0; 1.5; 1.7]
3-element Array{Float64,1}:
 1.0
 1.5
 1.7

julia&gt; interiornodes(x̄)
1-element Array{Float64,1}:
 1.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/b39dc5dc2706609a8b4fb01c16a1dba3c064d316/src/operators.jl#L260-L281">source</a></section><footer><hr/><a class="previous" href="../notebooks/"><span class="direction">Previous</span><span class="title">Notebooks</span></a></footer></article></body></html>
