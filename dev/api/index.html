<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SimpleDifferentialOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleDifferentialOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">﻿SimpleDifferentialOperators.jl</a></li><li><a class="toctext" href="../notebooks/">Notebooks</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><ul><li><a href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a></li><li><a href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a></li><li><a href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a></li><li><a href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a></li><li><a href="#SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{BoundaryCondition,BoundaryCondition},BackwardFirstDifference}"><code>SimpleDifferentialOperators.DifferentialOperator</code></a></li><li><a href="#SimpleDifferentialOperators.ExtensionDifferentialOperator-Tuple{AbstractRange,BackwardFirstDifference}"><code>SimpleDifferentialOperators.ExtensionDifferentialOperator</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₊-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₊</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₊bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₊bc</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₋-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₋</code></a></li><li><a href="#SimpleDifferentialOperators.L₁₋bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₋bc</code></a></li><li><a href="#SimpleDifferentialOperators.L₂-Tuple{Any}"><code>SimpleDifferentialOperators.L₂</code></a></li><li><a href="#SimpleDifferentialOperators.L₂bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₂bc</code></a></li><li><a href="#SimpleDifferentialOperators.Lₙ-Tuple{Any,Any}"><code>SimpleDifferentialOperators.Lₙ</code></a></li><li><a href="#SimpleDifferentialOperators.Lₙbc-Tuple{Any,Any,Any}"><code>SimpleDifferentialOperators.Lₙbc</code></a></li><li><a href="#SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{BoundaryCondition,BoundaryCondition}}"><code>SimpleDifferentialOperators.extrapolatetoboundary</code></a></li><li><a href="#SimpleDifferentialOperators.interiornodes-Tuple{Any,Any}"><code>SimpleDifferentialOperators.interiornodes</code></a></li><li><a href="#SimpleDifferentialOperators.interiornodes-Tuple{Any}"><code>SimpleDifferentialOperators.interiornodes</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{BoundaryCondition,BoundaryCondition},BackwardFirstDifference}" href="#SimpleDifferentialOperators.DifferentialOperator-Tuple{Any,Tuple{BoundaryCondition,BoundaryCondition},BackwardFirstDifference}"><code>SimpleDifferentialOperators.DifferentialOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DifferentialOperator(x̄, bc::Tuple{BoundaryCondition, BoundaryCondition}, method::DiscretizationMethod)</code></pre><p>Returns a discretized differential operator of  <code>length(interiornodes(x̄))</code> by <code>length(interiornodes(x̄))</code> matrix under mixed boundary conditions from <code>bc</code> using a discretization method specified by <code>method</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; DifferentialOperator(x̄, (Reflecting(), Reflecting()), BackwardFirstDifference())
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
  0.0   0.0    ⋅    ⋅
 -1.0   1.0   0.0   ⋅
   ⋅   -1.0   1.0  0.0
   ⋅     ⋅   -1.0  1.0

julia&gt; DifferentialOperator(x̄, (Reflecting(), Reflecting()), ForwardFirstDifference())
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
 -1.0   1.0    ⋅    ⋅
  0.0  -1.0   1.0   ⋅
   ⋅    0.0  -1.0  1.0
   ⋅     ⋅    0.0  0.0

julia&gt; DifferentialOperator(x̄, (Reflecting(), Reflecting()), CentralSecondDifference())
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
 -1.0   1.0    ⋅     ⋅
  1.0  -2.0   1.0    ⋅
   ⋅    1.0  -2.0   1.0
   ⋅     ⋅    1.0  -1.0

julia&gt; x̄ = 0:5
0:5

julia&gt; DifferentialOperator(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)), BackwardFirstDifference())
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
 Inf     0.0    ⋅    ⋅
  -1.0   1.0   0.0   ⋅
    ⋅   -1.0   1.0  0.0
    ⋅     ⋅   -1.0  1.0

julia&gt; DifferentialOperator(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)), ForwardFirstDifference())
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
 -1.0   1.0    ⋅     ⋅
  0.0  -1.0   1.0    ⋅
   ⋅    0.0  -1.0   1.0
   ⋅     ⋅    0.0  -0.5

julia&gt; DifferentialOperator(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)), CentralSecondDifference())
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
 -Inf     1.0    ⋅     ⋅
    1.0  -2.0   1.0    ⋅
     ⋅    1.0  -2.0   1.0
     ⋅     ⋅    1.0  -1.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L1-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.ExtensionDifferentialOperator-Tuple{AbstractRange,BackwardFirstDifference}" href="#SimpleDifferentialOperators.ExtensionDifferentialOperator-Tuple{AbstractRange,BackwardFirstDifference}"><code>SimpleDifferentialOperators.ExtensionDifferentialOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ExtensionDifferentialOperator(x̄, method::DiscretizationMethod)</code></pre><p>Returns a discretized differential operator of  <code>length(interiornodes(x̄))</code> by <code>length(x̄)</code> matrix under no boundary condition using a discretization method specified by <code>method</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; ExtensionDifferentialOperator(x̄, BackwardFirstDifference())
4×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 8 stored entries:
  [1, 1]  =  -1.0
  [1, 2]  =  1.0
  [2, 2]  =  -1.0
  [2, 3]  =  1.0
  [3, 3]  =  -1.0
  [3, 4]  =  1.0
  [4, 4]  =  -1.0
  [4, 5]  =  1.0

julia&gt; ExtensionDifferentialOperator(x̄, ForwardFirstDifference())
4×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 8 stored entries:
  [1, 2]  =  -1.0
  [1, 3]  =  1.0
  [2, 3]  =  -1.0
  [2, 4]  =  1.0
  [3, 4]  =  -1.0
  [3, 5]  =  1.0
  [4, 5]  =  -1.0
  [4, 6]  =  1.0

julia&gt; ExtensionDifferentialOperator(x̄, CentralSecondDifference())
4×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 12 stored entries:
  [1, 1]  =  1.0
  [1, 2]  =  -2.0
  [2, 2]  =  1.0
  [1, 3]  =  1.0
  [2, 3]  =  -2.0
  [3, 3]  =  1.0
  [2, 4]  =  1.0
  [3, 4]  =  -2.0
  [4, 4]  =  1.0
  [3, 5]  =  1.0
  [4, 5]  =  -2.0
  [4, 6]  =  1.0

julia&gt; ExtensionDifferentialOperator(x̄, JumpProcess(x̄, -1.0))
4×6 BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:
 0.0  0.0    ⋅     ⋅     ⋅    ⋅
  ⋅   1.0  -1.0    ⋅     ⋅    ⋅
  ⋅    ⋅    1.0  -1.0    ⋅    ⋅
  ⋅    ⋅     ⋅    1.0  -1.0   ⋅</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/extensionoperators.jl#L1-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₊-Tuple{Any}" href="#SimpleDifferentialOperators.L₁₊-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₊</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₊(x̄)</code></pre><p>Returns a discretized first-order differential operator of <code>length(interiornodes(x̄))</code> by <code>length(x̄)</code> matrix using forward difference under no boundary condition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; Array(L₁₊(x̄))
4×6 Array{Float64,2}:
 0.0  -1.0   1.0   0.0   0.0  0.0
 0.0   0.0  -1.0   1.0   0.0  0.0
 0.0   0.0   0.0  -1.0   1.0  0.0
 0.0   0.0   0.0   0.0  -1.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L309-L328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₊bc-Tuple{Any,Any}" href="#SimpleDifferentialOperators.L₁₊bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₊bc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₊bc(x̄, bc::Tuple{BoundaryCondition, BoundaryCondition})</code></pre><p>Returns a discretized first-order differential operator of  <code>length(interiornodes(x̄))</code> by <code>length(interiornodes(x̄))</code> matrix using forward difference under boundary conditions specified by <code>bc</code>.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; L₁₊bc(x̄, (Reflecting(), Reflecting()))
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
 -1.0   1.0    ⋅    ⋅
  0.0  -1.0   1.0   ⋅
   ⋅    0.0  -1.0  1.0
   ⋅     ⋅    0.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L220-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₋-Tuple{Any}" href="#SimpleDifferentialOperators.L₁₋-Tuple{Any}"><code>SimpleDifferentialOperators.L₁₋</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₋(x̄)</code></pre><p>Returns a discretized first-order differential operator of  <code>length(interiornodes(x̄))</code> by <code>length(x̄)</code> matrix using backward difference under no boundary condition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 1:3
1:3

julia&gt; Array(L₁₋(x̄))
1×3 Array{Float64,2}:
 -1.0  1.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L290-L306">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₁₋bc-Tuple{Any,Any}" href="#SimpleDifferentialOperators.L₁₋bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₁₋bc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₁₋bc(x̄, bc::Tuple{BoundaryCondition, BoundaryCondition})</code></pre><p>Returns a discretized first-order differential operator of  <code>length(interiornodes(x̄))</code> by <code>length(interiornodes(x̄))</code> matrix using backward difference under boundary conditions specified by <code>bc</code>.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; L₁₋bc(x̄, (Reflecting(), Reflecting()))
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
  0.0   0.0    ⋅    ⋅
 -1.0   1.0   0.0   ⋅
   ⋅   -1.0   1.0  0.0
   ⋅     ⋅   -1.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L196-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₂-Tuple{Any}" href="#SimpleDifferentialOperators.L₂-Tuple{Any}"><code>SimpleDifferentialOperators.L₂</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₂(x̄)</code></pre><p>Returns a discretized second-order differential operator of <code>length(interiornodes(x̄))</code> by <code>length(x̄)</code> matrix using central difference under no boundary condition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5 

julia&gt; Array(L₂(x̄))
4×6 Array{Float64,2}:
 1.0  -2.0   1.0   0.0   0.0  0.0
 0.0   1.0  -2.0   1.0   0.0  0.0
 0.0   0.0   1.0  -2.0   1.0  0.0
 0.0   0.0   0.0   1.0  -2.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L331-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.L₂bc-Tuple{Any,Any}" href="#SimpleDifferentialOperators.L₂bc-Tuple{Any,Any}"><code>SimpleDifferentialOperators.L₂bc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L₂bc(x̄, bc::Tuple{BoundaryCondition, BoundaryCondition})</code></pre><p>Returns a discretized second-order differential operator of  <code>length(interiornodes(x̄))</code> by <code>length(interiornodes(x̄))</code> matrix using central difference under boundary conditions specified by <code>bc</code>.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; L₂bc(x̄, (Reflecting(), Reflecting()))
4×4 LinearAlgebra.Tridiagonal{Float64,Array{Float64,1}}:
 -1.0   1.0    ⋅     ⋅
  1.0  -2.0   1.0    ⋅
   ⋅    1.0  -2.0   1.0
   ⋅     ⋅    1.0  -1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L244-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.Lₙ-Tuple{Any,Any}" href="#SimpleDifferentialOperators.Lₙ-Tuple{Any,Any}"><code>SimpleDifferentialOperators.Lₙ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Lₙ(x̄, method)</code></pre><p>Returns a discretized jump process operator of <code>length(interiornodes(x̄))</code> by <code>length(x̄)</code> matrix specified by <code>method</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5 

julia&gt; Lₙ(x̄, JumpProcess(x̄, -1.0))
4×6 BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:
 0.0  0.0    ⋅     ⋅     ⋅    ⋅
  ⋅   1.0  -1.0    ⋅     ⋅    ⋅
  ⋅    ⋅    1.0  -1.0    ⋅    ⋅
  ⋅    ⋅     ⋅    1.0  -1.0   ⋅</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L353-L372">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.Lₙbc-Tuple{Any,Any,Any}" href="#SimpleDifferentialOperators.Lₙbc-Tuple{Any,Any,Any}"><code>SimpleDifferentialOperators.Lₙbc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Lₙbc(x̄, method, (Absorbing(), Absorbing()))</code></pre><p>Returns a discretized jump process operator of <code>length(interiornodes(x̄))</code> by <code>length(interiornodes(x̄))</code> matrix specified by <code>method</code> under boundary conditions specified by <code>bc</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5 

julia&gt; Lₙbc(x̄, (Absorbing(), Absorbing()), JumpProcess(x̄, -1.0))
4×4 BandedMatrices.BandedMatrix{Float64,Array{Float64,2},Base.OneTo{Int64}}:
 0.0   0.0    ⋅     ⋅
 1.0  -1.0   0.0    ⋅
  ⋅    1.0  -1.0   0.0
  ⋅     ⋅    1.0  -1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L268-L287">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{BoundaryCondition,BoundaryCondition}}" href="#SimpleDifferentialOperators.extrapolatetoboundary-Tuple{Any,Any,Tuple{BoundaryCondition,BoundaryCondition}}"><code>SimpleDifferentialOperators.extrapolatetoboundary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extrapolatetoboundary(v, x̄, bc::Tuple{BoundaryCondition, BoundaryCondition})</code></pre><p>Returns a <code>length(x̄)</code>-vector whose <code>2:(length(x̄)-1)</code> elements are <code>v</code>, the first and last element are extrapolated <code>v</code> on the boundaries of <code>x̄</code> according to boundary conditions <code>bc</code> given.</p><p>The first element of <code>bc</code> is applied to the lower bound, and second element of <code>bc</code> to the upper.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = -2:2
-2:2

julia&gt; x = interiornodes(x̄)
-1:1

julia&gt; v = (x -&gt; x^2).(x)
3-element Array{Int64,1}:
 1
 0
 1

julia&gt; extrapolatetoboundary(v, x̄, (Absorbing(), Absorbing()))
5-element Array{Int64,1}:
 0
 1
 0
 1
 0

julia&gt; extrapolatetoboundary(v, x̄, (Absorbing(), Reflecting()))
5-element Array{Int64,1}:
 0
 1
 0
 1
 1

julia&gt; extrapolatetoboundary(v, x̄, (Mixed(ξ = 3.0), Reflecting()))
5-element Array{Float64,1}:
 -0.5
  1.0
  0.0
  1.0
  1.0
  </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/utilities/extrapolatetoboundary.jl#L1-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.interiornodes-Tuple{Any,Any}" href="#SimpleDifferentialOperators.interiornodes-Tuple{Any,Any}"><code>SimpleDifferentialOperators.interiornodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interiornodes(x̄, bc)</code></pre><p>Returns an interior grid corresponding to the boundary condition <code>bc</code> given extended grid <code>x̄</code>.</p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; interiornodes(x̄, (Reflecting(), Reflecting()))
1:4

julia&gt; x̄ = [1.0; 1.5; 1.7]
3-element Array{Float64,1}:
 1.0
 1.5
 1.7

julia&gt; interiornodes(x̄, (Mixed(ξ = 1.0), Mixed(ξ = 1.0)))
1-element Array{Float64,1}:
 1.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L399-L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.interiornodes-Tuple{Any}" href="#SimpleDifferentialOperators.interiornodes-Tuple{Any}"><code>SimpleDifferentialOperators.interiornodes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">interiornodes(x̄)</code></pre><p>Returns an interior grid of length <code>length(x̄)-2</code> given extended grid <code>x̄</code>.</p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; interiornodes(x̄)
1:4

julia&gt; x̄ = [1.0; 1.5; 1.7]
3-element Array{Float64,1}:
 1.0
 1.5
 1.7

julia&gt; interiornodes(x̄)
1-element Array{Float64,1}:
 1.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/operators.jl#L375-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.JumpProcess" href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>JumpProcess(x̄, jumps::AbstractArray, truncate = (:interior, :interior))</p><p>Returns a DiscretizationMethod object that can be used to construct  a discretized operator jump process. </p><p><code>jumps</code> is a <code>(length(x̄)-2)</code>-vector whose ith element is an integer that represents  a jump size in index and direction (by sign) from <code>i</code>th element of <code>interiornodes(x̄)</code> and the first and second elements of <code>truncate</code> represent truncation location for  the lower bound and upper bound when the jump is out of the truncated boundary  (<code>:interior</code> for the first/last element of <code>interiornodes(̄x)</code> and <code>:exterior</code> for  the first/last element of <code>x̄</code>). The default parameter is <code>(:interior, :interior)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; JumpProcess(x̄, [-1; -1; -1; -1], (:interior, :interior))
JumpProcess{Array{Int64,1}}([0, -1, -1, -1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/types.jl#L16-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.JumpProcess" href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>JumpProcess(x̄, jumpf::Function, truncate = (:interior, :interior))</p><p>Returns a DiscretizationMethod object that can be used to construct  a discretized operator jump process. </p><p><code>jumpf</code> is a function that takes an element of <code>interiornodes(x̄)</code> and returns  a scalar that represents the corresponding nominal jump size and direction (by sign) and the first and second elements of <code>truncate</code> represent truncation location for  the lower bound and upper bound when the jump is out of the truncated boundary  (<code>:interior</code> for the first/last element of <code>interiornodes(̄x)</code> and <code>:exterior</code> for  the first/last element of <code>x̄</code>). The default parameter is <code>(:interior, :interior)</code>. The code uses nearest-neighbour rule to determine the indices of destinations according to `jumpf.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; jumpf(x) = -1.4
jumpf (generic function with 1 method)

julia&gt; JumpProcess(x̄, jumpf)
JumpProcess{Array{Int64,1}}([0, -1, -1, -1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/types.jl#L82-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.JumpProcess" href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>JumpProcess(x̄, uniform<em>jump</em>size::Real, truncate = (:interior, :interior))</p><p>Returns a DiscretizationMethod object that can be used to construct  a discretized operator jump process. </p><p><code>uniform_jump_size</code> is a scalar in Real that represents a nominal jump size  and direction (by sign) from all elements of <code>interiornodes(x̄)</code> and the first and second elements of <code>truncate</code> represent truncation location for  the lower bound and upper bound when the jump is out of the truncated boundary  (<code>:interior</code> for the first/last element of <code>interiornodes(̄x)</code> and <code>:exterior</code> for  the first/last element of <code>x̄</code>). The default parameter is <code>(:interior, :interior)</code>. The code uses nearest-neighbour rule to determine the indices of destinations according to `jumpf.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; JumpProcess(x̄, -1.4)
JumpProcess{Array{Int64,1}}([0, -1, -1, -1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/types.jl#L135-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimpleDifferentialOperators.JumpProcess" href="#SimpleDifferentialOperators.JumpProcess"><code>SimpleDifferentialOperators.JumpProcess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>JumpProcess(x̄, uniform_jump::AbstractArray, truncate = (:interior, :interior))</p><p>Returns a DiscretizationMethod object that can be used to construct  a discretized operator jump process. </p><p><code>uniform_jump</code> is a scalar Int64 that represents a jump size in index  and direction (by sign) from all elements of <code>interiornodes(x̄)</code> and the first and second elements of <code>truncate</code> represent truncation location for  the lower bound and upper bound when the jump is out of the truncated boundary  (<code>:interior</code> for the first/last element of <code>interiornodes(̄x)</code> and <code>:exterior</code> for  the first/last element of <code>x̄</code>). The default parameter is <code>(:interior, :interior)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x̄ = 0:5
0:5

julia&gt; JumpProcess(x̄, -1)
JumpProcess{Array{Int64,1}}([0, -1, -1, -1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/8c003d430c89715f6f5c62c615d1aa73a7939809/src/types.jl#L58-L79">source</a></section><footer><hr/><a class="previous" href="../notebooks/"><span class="direction">Previous</span><span class="title">Notebooks</span></a></footer></article></body></html>
