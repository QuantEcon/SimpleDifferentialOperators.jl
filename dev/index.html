<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>﻿Installation · SimpleDifferentialOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleDifferentialOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>﻿Installation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Usage-1">Usage</a></li><li class="toplevel"><a class="toctext" href="#Examples-1">Examples</a></li></ul></li><li><a class="toctext" href="notebooks/">Notebooks</a></li><li><a class="toctext" href="derivations/">Derivations</a></li><li><a class="toctext" href="api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>﻿Installation</a></li></ul><a class="edit-page" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>﻿Installation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Installation-1" href="#Installation-1">﻿Installation</a></h1><p>To install, run</p><pre><code class="language-julia">] add SimpleDifferentialOperators</code></pre><p>Note that this requires Julia 1.0 or later.</p><h1><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h1><p>Consider solving for <code>v</code> from the following equation:</p><div>\[\rho v(x) = f(x) + \mu \partial_x v(x) + \frac{\sigma^2}{2} \partial_{xx} v(x)\]</div><p>for some constant <span>$\rho, \sigma &gt; 0$</span> and <span>$\mu \leq 0$</span>. To solve <code>v</code> on <code>M</code>-size discretized grids, one can run the following code:</p><pre><code class="language-julia"># import LinearAlgebra package (for diagonal and identity matrices)
using LinearAlgebra 
# setup 
f(x) = x^2 
μ = -0.1 # constant negative drift
σ = 0.1
ρ = 0.05
M = 100 # size of grid
x = range(0.0, 1.0, length = M) # grid

# discretize L = ρ - μ D_x - σ^2 / 2 D_xx
# subject to reflecting barriers at 0 and 1
bc = (Reflecting(), Reflecting())
L = I * ρ - μ*L₁₋(x, bc) - σ^2 / 2 * L₂(x, bc)
## solve the value function
v_bc = L \ f.(x) </code></pre><p>Note that the code above uses differential operators with reflecting boundary conditions applied.  One can alternatively use differential operators on interior nodes and stack them with matrices for boundary conditions to compute <code>v</code>:</p><pre><code class="language-julia"># operators without boundary conditions, adding extra two rows for boundary conditions
## differential operators on extended nodes
A = μ*L̄₁₋(x) + σ^2 / 2 * L̄₂(x)
## matrix for boundary conditions
B = transpose([[-1; 1; zeros(M)] [zeros(M); -1; 1]]) 
## stack them together
L = [([zeros(M) Diagonal(ones(M,M)) zeros(M)] * 0.05 - A); B] 
## solve the value function with reflecting barrier bc (last two elements)
v_bar = L \ [f.(x); 0.0; 0.0] 
## extract the interior (is identical with `v_bc` above)
v_interior = v_bar[2:end-1] </code></pre><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><p>One can also deploy upwind schemes when drift variable is not constant. Consider solving for <code>v</code> from the following equation:</p><div>\[\rho v(x) = f(x) + \mu(x) \partial_x v(x) + \frac{\sigma^2}{2} \partial_{xx} v(x)\]</div><p>for some constant <span>$\rho, \sigma &gt; 0$</span> and <span>$\mu(x) = -x$</span>. Note that <span>$\mu(x)$</span> depends on states. The following code will solve <code>v</code> using upwind schemes:</p><pre><code class="language-julia"># setup 
f(x) = x^2 
μ(x) = -x # drift depends on state
σ = 0.1
ρ = 0.05
M = 100 # size of grid
x = range(-1.0, 1.0, length = 100)

bc = (Reflecting(), Reflecting())

# Define first order differential operator using upwind scheme
L₁ = Diagonal(min.(μ.(x), 0.0)) * L₁₋(x, bc) + Diagonal(max.(μ.(x), 0.0)) * L₁₊(x, bc)

# Define linear operator using upwind schemes
L = I * ρ - L₁ - σ^2 / 2 * L₂(x,bc)

# solve the value function
v_bc = L \ f.(x) </code></pre><footer><hr/><a class="next" href="notebooks/"><span class="direction">Next</span><span class="title">Notebooks</span></a></footer></article></body></html>
