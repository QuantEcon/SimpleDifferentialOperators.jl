<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Derivations · SimpleDifferentialOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleDifferentialOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">﻿Installation</a></li><li><a class="toctext" href="../notebooks/">Notebooks</a></li><li class="current"><a class="toctext" href>Derivations</a><ul class="internal"><li><a class="toctext" href="#Setup-1">Setup</a></li><li><a class="toctext" href="#Mixed-Boundary-Values-1">Mixed Boundary Values</a></li><li><a class="toctext" href="#Applying-boundary-conditions-with-operators-on-extended-grids-1">Applying boundary conditions with operators on extended grids</a></li><li><a class="toctext" href="#Applications-1">Applications</a></li></ul></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Derivations</a></li></ul><a class="edit-page" href="https://github.com/QuantEcon/SimpleDifferentialOperators.jl/blob/master/docs/src/derivations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Derivations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Derivations-1" href="#Derivations-1">Derivations</a></h1><p>Detailed derivation, including formula for irregular grids, can be found <a href="../generated/discretized-differential-operator-derivation.pdf">here</a>.</p><h2><a class="nav-anchor" id="Setup-1" href="#Setup-1">Setup</a></h2><p>Let <span>$\{x_i\}_{i=1}^M$</span> be a collection of discretized <span>$M$</span>-length of grids on <span>$x$</span> with end points <span>$x_1 = x_{\min}$</span> and <span>$x_M = x_{\max}$</span>. Also, throughout the section, we consider regular grids, i.e., <span>$x_{i+1} - x_i = \Delta$</span> for some constant <span>$\Delta &gt; 0$</span> for all <span>$i = 1, ..., M-1$</span>. Also, given a real-valued function <span>$v$</span>, let <span>$v(x)$</span> be the <span>$M$</span>-length vector whose <span>$i$</span>th element is <span>$v(x_i)$</span>. The goal is to construct a matrix <span>$L$</span> such that <span>$L v(x)$</span> represents the first-order or second-order derivative of <span>$v$</span> on <span>$x$</span> under some boundary conditions.</p><h2><a class="nav-anchor" id="Mixed-Boundary-Values-1" href="#Mixed-Boundary-Values-1">Mixed Boundary Values</a></h2><p>Under <span>$M$</span>-length of grids on <span>$v$</span> with end points <span>$x_{\min} &lt; x_{\max}$</span> with mixed boundary value conditions of</p><div>\[\]</div><p>math \underline{\xi} v(x<em>{\min}) + \nabla v(x</em>{\min}) &amp;= 0\
\overline{\xi} v(x<em>{\max}) + \nabla v(x</em>{\max}) &amp;= 0</p><pre><code class="language-none"></code></pre><p>Note that this can be extended to reflecting boundary conditions by assigning <span>$\underline{\xi} = 0$</span> and <span>$\overline{\xi} = 0$</span>. We use the following discretization schemes:</p><div>\[L_{1-} \equiv \frac{1}{\Delta}\begin{pmatrix}
1 - (1 + \underline{\xi} \Delta) &amp;0&amp;0&amp;\dots&amp;0&amp;0&amp;0\\
-1&amp;1&amp;0&amp;\dots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;\dots&amp;-1&amp;1&amp;0\\
0&amp;0&amp;0&amp;\cdots&amp;0&amp;-1&amp;1
\end{pmatrix}_{M\times M}\]</div><div>\[L_{1+} \equiv \frac{1}{\Delta}\begin{pmatrix}
-1&amp;1&amp;0&amp;\dots&amp;0&amp;0&amp;0\\
0&amp;-1&amp;1&amp;\dots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;\dots&amp;0&amp;-1&amp;1\\
0&amp;0&amp;0&amp;\cdots&amp;0&amp;0&amp;-1+(1-\overline{\xi} \Delta)
\end{pmatrix}_{M\times M}\label{eq:L-1-plus-regular} \\\]</div><div>\[L_2 \equiv \frac{1}{\Delta^2}\begin{pmatrix}
-2 + (1 + \underline{\xi} \Delta) &amp;1&amp;0&amp;\dots&amp;0&amp;0&amp;0\\
1&amp;-2&amp;1&amp;\dots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;\dots&amp;1&amp;-2&amp;1\\
0&amp;0&amp;0&amp;\cdots&amp;0&amp;1&amp;-2 + (1- \overline{\xi} \Delta)
\end{pmatrix}_{M\times M}\label{eq:L-2-regular}\]</div><p>which represent the backward first order, foward first order, and central second order differential operators respectively.</p><h2><a class="nav-anchor" id="Applying-boundary-conditions-with-operators-on-extended-grids-1" href="#Applying-boundary-conditions-with-operators-on-extended-grids-1">Applying boundary conditions with operators on extended grids</a></h2><p>Boundary conditions can be applied manually by using operators on extended grids. This can be done by first extending <span>$x = \{x_i\}_{i=1}^M$</span> to $ \overline{x} = {x<em>i}</em>{i=0}^{M+1}$ where <span>$x_{i+1} - x_i = \Delta$</span> for some constant <span>$\Delta &gt; 0$</span> for all <span>$i = 0, ..., M$</span>. We call <span>$x_0$</span> and <span>$x_{M+1}$</span>, extra nodes just before and after <span>$x_{\min}$</span> and <span>$x_{\max}$</span>, as ghost nodes. Likewise, define <span>$v(\overline{x})$</span> as <span>$(M+2)$</span>-vector whose <span>$i$</span>th element is <span>$\overline {x}_i$</span>. We can then define the following operators on <span>$\overline{x}$</span>:</p><div>\[\overline{L}_{1-} \equiv \frac{1}{\Delta}\begin{pmatrix}
-1&amp;1&amp;0&amp;\dots&amp;0&amp;0&amp;0\\
0&amp;-1&amp;1&amp;\dots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;\dots&amp;1&amp;0&amp;0\\
0&amp;0&amp;0&amp;\cdots&amp;-1&amp;1&amp;0
\end{pmatrix}_{M\times (M+2)}\]</div><div>\[\overline{L}_{1+} \equiv \frac{1}{\Delta}\begin{pmatrix}
0&amp;-1&amp;1&amp;\dots&amp;0&amp;0&amp;0\\
0&amp;0&amp;-1&amp;\dots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;\dots&amp;-1&amp;1&amp;0\\
0&amp;0&amp;0&amp;\cdots&amp;0&amp;-1&amp;1
\end{pmatrix}_{M\times (M+2)} \]</div><div>\[\overline{L}_2 \equiv \frac{1}{\Delta^2}\begin{pmatrix}
-1&amp;2&amp;-1&amp;\dots&amp;0&amp;0&amp;0\\
0&amp;-1&amp;2&amp;\dots&amp;0&amp;0&amp;0\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots\\
0&amp;0&amp;0&amp;\dots&amp;2&amp;-1&amp;0\\
0&amp;0&amp;0&amp;\cdots&amp;-1&amp;2&amp;1
\end{pmatrix}_{M\times (M+2)}\]</div><p>Suppose that we want to solve a system <span>$L v({x}) = f(x) $ where $L$</span> is a linear combination of discretized differential operators for some <span>$f(x)$</span> that represents the values of a function <span>$f$</span> on discretized <span>$x$</span>. To solve the system under boundary conditions on <span>$v$</span>, one can construct and solve the following extended system:</p><div>\[\begin{bmatrix}
\overline{L} \\
B
\end{bmatrix} 
v(\overline{x}) = 
\begin{bmatrix}
f(x) \\
b
\end{bmatrix} \]</div><p>with <span>$M_E$</span> by <span>$(M+2)$</span> matrix <span>$B$</span> and <span>$M_E$</span>-length vector <span>$b$</span> that represent the current boundary conditions, where <span>$M_E$</span> is the number of boundary conditions to be applied. For instance, to apply reflecting barrier conditions <span>$v&#39;(x_{\min}) = v&#39;(x_{\max}) = 0$</span>, one can use</p><div>\[B = \begin{bmatrix}
1 &amp; -1 &amp; 0 &amp; \dots &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \dots &amp; 0 &amp; -1 &amp; 1\\
\end{bmatrix}_{2 \times (M+2)} \quad 
b = \begin{bmatrix}
0 \\
0
\end{bmatrix}\]</div><p>Likewise, for mixed boundary conditions <span>$v&#39;(x_{\min}) = \underline{\xi}$</span> and <span>$v&#39;(x_{\max}) = \overline{\xi}$</span>, one can use</p><div>\[B = \begin{bmatrix}
1 &amp; -1 &amp; 0 &amp; \dots &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \dots &amp; 0 &amp; -1 &amp; 1\\
\end{bmatrix}_{2 \times (M+2)} \quad 
b = \begin{bmatrix}
 \underline{\xi} \Delta \\
\overline{\xi} \Delta
\end{bmatrix}\]</div><h2><a class="nav-anchor" id="Applications-1" href="#Applications-1">Applications</a></h2><h3><a class="nav-anchor" id="Hamilton–Jacobi–Bellman-equations-(HJBE)-1" href="#Hamilton–Jacobi–Bellman-equations-(HJBE)-1">Hamilton–Jacobi–Bellman equations (HJBE)</a></h3><p>Consider solving for <span>$v$</span> from the following optimal control problem</p><div>\[v(x_0) = \max_{ {\{\alpha(t) \} }_{t \geq 0} } \int_{0}^\infty e^{-\rho t} r( x(t), \alpha(t )) dt\]</div><p>with the law of motion for the state </p><div>\[dx = \mu dt + \sigma dW \]</div><p>for some constant <span>$\mu \geq 0$</span> and <span>$\sigma \geq 0$</span> with <span>$x(0) = x_0$</span>.</p><p>Let <span>$\alpha^*(t)$</span> be the optimal solution. Suppose that <span>$r$</span> under <span>$\alpha^*(t)$</span> can be expressed in terms of state variables, <span>$r^* (x)$</span>. Then, the HJBE yields</p><pre><code class="language-math">\rho v(x) = r^*(x) +  \mu  \partial_{x} v(x) + \dfrac{\sigma^2}{2} \partial_{xx} v(x)</code></pre><p>In terms of differential operators, one can rewrite the equation as</p><pre><code class="language-math">(\rho - \tilde{L}) v(x) = r^*(x)</code></pre><p>where </p><pre><code class="language-math">\tilde{L} = \mu \partial_{x} + (\sigma^2/2) \partial_{xx}</code></pre><p>By descretizing the space of <span>$x$</span>, one can solve the corresponding system by using discretized operators for <span>$\partial_{x}$</span> (<span>$L_{1+}$</span>), <span>$\partial_{xx}$</span> (<span>$L_2$</span>) on some grids of length <span>$M$</span>, <span>$\{x_i\}_{i=1}^M$</span>:</p><div>\[L = \mu L_{1+} + \dfrac{\sigma^2}{2} L_{2}\]</div><p>so that <span>$v$</span> under the optimal plan can be computed by solving the following discretized system of equations:</p><div>\[(\rho I - L) v &amp;= r^*\]</div><p>where <span>$v$</span> and <span>$r^*$</span> are <span>$M$</span>-vectors whose <span>$i$</span>th elements are <span>$v(x_i)$</span> and <span>$r^*(x_i)$</span>, respectively.</p><h3><a class="nav-anchor" id="Kolmogorov-forward-equations-(KFE)-under-diffusion-process-1" href="#Kolmogorov-forward-equations-(KFE)-under-diffusion-process-1">Kolmogorov forward equations (KFE) under diffusion process</a></h3><p>Let <span>$g(x, t)$</span> be the distribution of <span>$x$</span> at time <span>$t$</span> from the example above. By the Kolmogorov forward equation, the following PDE holds:</p><pre><code class="language-math">\partial_{t} g(x, t) = - \mu \partial_{x}  g(x,t) + \dfrac{\sigma^2}{2} \partial_{xx} g(x,t)</code></pre><h4><a class="nav-anchor" id="Stationary-distributions-1" href="#Stationary-distributions-1">Stationary distributions</a></h4><p>The stationary distribution <span>$g^*(x)$</span> satisfies</p><div>\[0 = - \mu \partial_{x} g^*(x) + \dfrac{\sigma^2}{2} \partial_{xx} g^*(x)\]</div><p>which can be rewritten as </p><div>\[\tilde{L}^* g(x) = 0\]</div><p>where </p><div>\[\tilde{L}^* =  - \mu \partial_{x} + (\sigma^2/2) \partial_{xx}\]</div><p>By descretizing the space of <span>$x$</span>, one can solve the corresponding system by using discretized operators for <span>$\tilde{L}^*$</span>. Note that the operator for the KFE in the original equation is the adjoint operator of the operator for the HJBE, <span>$\tilde{L}$</span>, and the correct discretization scheme for <span>$L^*$</span> is, analogously, done by taking the transpose of the discretized operator for HJBE, <span>$L$</span> (See <a href="https://doi.org/10.3982/ECTA13569">Gabaix et al., 2016</a>). Hence, one can find the stationary distribution by solving the following discretized system of equations:</p><div>\[L^T g = 0 \]</div><p>where <span>$L^T$</span> is the transpose of <span>$L$</span> and <span>$g$</span> is an <span>$M$</span>-vector whose element is <span>$g(x_i)$</span> such that <span>$\sum_{i=1}^M g(x_i) = 1$</span>.</p><h4><a class="nav-anchor" id="Full-dynamics-of-distributions-1" href="#Full-dynamics-of-distributions-1">Full dynamics of distributions</a></h4><p>One can also solve the full PDE in KFE equation, given an initial distribution <span>$g(x, 0)$</span>. After discretization, note that \eqref{eq:kfe} can be rewritten as</p><div>\[\dot{g}(t) = L^T g(t)\]</div><p>where <span>$\dot{g}(t)$</span> is an <span>$M$</span>-vector whose <span>$i$</span>th element is <span>$\partial_{t} g(x_i, t)$</span>, which can be efficently solved by a number of differential equation solvers available in public, including <a href="http://doi.org/10.5334/jors.151">DifferentialEquations.jl</a>.</p><footer><hr/><a class="previous" href="../notebooks/"><span class="direction">Previous</span><span class="title">Notebooks</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
